# from internet import Internet
from modules.internet import Internet
from requests import get
from json import loads, dump 
# Breach Directory Attributes : 
#     self.
#         __JsonKeys 
#         __BreachDirHeaders
#         __AutoResponse


class BreachDir(Internet):

    def __init__(self):
        self.__JsonKeys = loads(str(open('APIkeys.json', 'r').read()))  # ? SurfaceNet.json.loads()
        self.__GetValidKey
        self.__BreachDirHeaders = {
            "X-RapidAPI-Host": "breachdirectory.p.rapidapi.com",
            "X-RapidAPI-Key": self.__ValidKey  # ! Get your API key -> https://rapidapi.com/rohan-patra/api/breachdirectory
        }
        
        
    @property
    def __GetValidKey(self):    
        self.AddStatus('[-] Getting Valid API Key [-]')   
        count = 100 
        MinKey = ''
        
        for key in self.__JsonKeys:
            if self.__JsonKeys[key] < count:
                count = self.__JsonKeys[key]
                MinKey = key
                
                
        if self.__JsonKeys[MinKey] == 50:
            #! show Error Windows "all the keys are invalid "
            pass 
        else:
            self.__ValidKey = MinKey
        


    def __UpdateKeyCounters(self):
        self.__JsonKeys[self.__ValidKey] += 1
        self.__UpdateKeysFile()
        
    
    
    def __UpdateKeysFile(self):
        file = open("APIkeys.json", 'w')
        dump(self.__JsonKeys, file) # ? SurfaceNet.json.dump()
        file.close()



    def Search(self):
        self.AddStatus("[*] Searching in Breachdirectory.org [*]")
        querystring = {"func": "auto", "term": f"{self.GetSearchKey}"}
        res = get("https://breachdirectory.p.rapidapi.com/", headers=self.__BreachDirHeaders, params=querystring)
        self.AddStatus('[-] Search Result received [-]')
        self.__AutoJsResponse = loads(res.text) # ? internet.json.loads
        self.__UpdateKeyCounters()
        
        
        if 'message' in self.__AutoJsResponse:
            self.__GetValidKey
            self.Search()
        else:
            if self.__AutoJsResponse["success"]:
                self.__AutoJsResponse = self.__AutoJsResponse["result"] 
                self.AddStatus('[+] Passwords Found in Breach Directory [+]')
                self.AddResult("Passwords Found in Breach Directory:\n ")
                for password in self.__GetPasswords:
                    self.AddResult(password)
                    self.IncreaseRiskLevel()
                
                for source in self.__GetSources:
                    self.AddSource(source)
                
            
            else:
                self.AddStatus('[+] No Breaches found in BreachDirectory [+]')
                self.AddResult("No Breaches found in BreachDirectory")
            
        
        
    @property
    def __GetSources(self):
        
        querystring = {"func": "sources", "term": f"{self.GetSearchKey}"}
        self.__UpdateKeyCounters()
        return loads(get("https://breachdirectory.p.rapidapi.com/", headers=self.__BreachDirHeaders, params=querystring).text.replace("'", '"'))['sources'] # ? internet.json.loads()
    
    
    @property
    def __GetPasswords(self):
        passwds = []
        for breach in self.__AutoJsResponse:
            if breach["has_password"]:
                passwds.append(breach["password"])
        return passwds 
    

# Hawash, Bassel, Azab
# Darknet class is a child of internet class 


# ! Search Type (Email or Username) don't support phone number or visa card 
from modules.internet import Internet
from requests import session, get
from bs4 import BeautifulSoup
import socks
import socket
from os import system
from sys import platform
from time import sleep
from threading import Thread 



"""
Attribues 
self.
    __ResponseHeaders (hold the cookies)
    __soup (hold the main page, EVENTVALIDATION, VIEWSTATE and VIEWSTATEGENERATOR)
    __ASP_SessionId
    __AntiXsrfToken
    __EVENTVALIDATION
    __VIEWSTATE
    __VIEWSTATEGENERATOR
"""

# ? class name(file_name.class_name)
class DarkNet(Internet):
    def __init__(self): 
        self.AddStatus('[-] Setting TOR Proxy [-]')
        self.session = session() # ? internet.requests.session()
        self.session.proxies["http"] = "socks5h://localhost:9050"
        self.session.proxies["https"] = "socks5h://localhost:9050"
    #   socks.set_default_proxy(proxy_type, addr, port)
        socks.set_default_proxy(socks.SOCKS5, "localhost", 9050)
        socket.socket = socks.socksocket
        self.__CheckTorConnection()
        self.__GetContent()
        
        


    def __CreateThreads(self):
        self.__GetEventThread = Thread(target=self.__Get_EVENTVALIDATION)
        self.__GetViewStatThread = Thread(target=self.__Get_VIEWSTATE)
        self.__GetViewGenThread = Thread(target=self.__Get_VIEWSTATEGENERATOR)
        self.__GetCookieThread = Thread(target=self.__GetCookies)
        self.__Threads = [self.__GetEventThread, self.__GetViewStatThread, self.__GetViewGenThread, self.__GetCookieThread]
        
        
    def __StartThreads(self):
        for thread in self.__Threads:
            thread.start()
        
        
    def __JoinThreads(self):
        for thread in self.__Threads:
            thread.join()


    # It is necessary for DNS resolution of Onion websites
    def GetAddrInfo(*args):
        return [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (args[0], args[1]))]

    socket.getaddrinfo = GetAddrInfo

    def __CheckTorConnection(self):
        self.AddStatus('[-] Checking TOR Connection [-]')
        URLs = [
            'http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion/LeakedPass', 
            'http://juhanurmihxlp77nkq76byazcldy2hlmovfu2epvl5ankdibsot4csyd.onion/', 
            'http://freedomzw5x5tzeit4jgc3gvic3bmecje53hwcoc3nnwe2c3gsukdfid.onion/databases',
            'http://3bbad7fauom4d6sgppalyqddsqbf5u5p56b5k5uk2zxsy3d6ey2jobad.onion/'
            ]
        for URL in URLs:
            try:
                self.AddStatus('[-] Requesting .onion site [-]')
                get(URL)
                break
            except:
                self.AddStatus('[-] Try to start TOR service [-]')

                #! Show Error window "Tor is not running"
                if platform == 'linux' or platform == 'Linux':
                    try:
                        print('starting tor will stop this program ')
                        system('tor 2>/dev/null 2>&1')
                        sleep(2)
                    except:
                        try:
                            system('apt install tor && systemctl start tor.service')
                            sleep(2)
                        except:
                            #! show error window "Install tor manually please before running the program (follow your distro documentation)"
                            pass
                else: 
                    #? Windows or Mac
                    #! Show Error window "please, start tor manually  before using the program"
                    pass
    
    
    def __GetContent(self):
        self.AddStatus('[-] Establishing TOR Connection [-]')
        res = get('http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion/LeakedPass')  # ? internet.requests.get()
        self.AddStatus('[-] Onion Site Connected [-]')
        self.__ResponseHeaders = res.headers
        self.__soup = BeautifulSoup(res.content, 'lxml') 
        open('dar', 'w').write(str(res.headers))


    def __GetCookies(self):
        self.AddStatus('[-] Setting session Cookies [-]')        
        SetCookie = self.__ResponseHeaders['Set-Cookie']
        SetCookie = SetCookie.split()
        
        for cookie in SetCookie:
            if cookie.__contains__('ASP.NET_SessionId'):
                self.__ASP_SessionId = cookie.split('=')[1]
            elif  cookie.__contains__('AntiXsrfToken'):
                self.__AntiXsrfToken = cookie.split('=')[1]


    def __Get_EVENTVALIDATION(self):
        self.AddStatus('[-] Event Validation [-]')        
        # tag = self.__soup.find('input', {'type': 'hidden', 'id': '__EVENTVALIDATION'})
        # self.__EVENTVALIDATION = tag.attrs['value']
        self.__EVENTVALIDATION = self.__soup.find('input', {'type': 'hidden', 'id': '__EVENTVALIDATION'}).attrs['value']
        
        
    def __Get_VIEWSTATE(self):        
        # tag = self.__soup.find('input', {'type': 'hidden', 'id': '__VIEWSTATE'})
        # self.__VIEWSTATE = tag.attrs['value']
        self.__VIEWSTATE = self.__soup.find('input', {'type': 'hidden', 'id': '__VIEWSTATE'}).attrs['value']
        
        
    def __Get_VIEWSTATEGENERATOR(self):
        # tag = self.__soup.find('input', {'type': 'hidden', 'id': '__VIEWSTATEGENERATOR'})
        # self.__VIEWSTATEGENERATOR = tag.attrs['value']
        self.__VIEWSTATEGENERATOR = self.__soup.find('input', {'type': 'hidden', 'id': '__VIEWSTATEGENERATOR'}).attrs['value']
        
        
    def Search(self):
        self.__CreateThreads()
        self.__StartThreads()
        self.__JoinThreads()
        self.AddStatus('[*] Start Searching in the dark web [*]')
        LeaksHeaders = {
            'Host': 'leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; rv:91.0) Gecko/20100101 Firefox/91.0',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Referer': 'http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion/LeakedPass',
            'Content-Type': 'application/x-www-form-urlencoded',
            'Origin': 'http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion',
            'Connection': 'close',
            'Cookie': f'ASP.NET_SessionId={self.__ASP_SessionId} AntiXsrfToken={self.__AntiXsrfToken}',
            'Upgrade-Insecure-Requests':'1',
            'Sec-Fetch-Dest': 'document',
            'Sec-Fetch-Mode': 'navigate',
            'Sec-Fetch-Site': 'same-origin',
            'Sec-Fetch-User': '?1'
        }
        self.session.headers = LeaksHeaders
        InputData = {'__LASTFOCUS':	"", 
                    '__EVENTTARGET':"ctl00$ContentPlaceHolder1$BtnSearch",
                    '__EVENTARGUMENT':	"",
                    '__VIEWSTATE':	self.__VIEWSTATE,
                    '__VIEWSTATEGENERATOR':	self.__VIEWSTATEGENERATOR,
                    '__EVENTVALIDATION':	self.__EVENTVALIDATION,
                    'ctl00$ContentPlaceHolder1$TxtSearch':	self.GetSearchKey,
                    'ctl00$ContentPlaceHolder1$SearchType':	self.GetSearchType
                    }

        # ? 1 res = self.session.post('http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion/LeakedPass', data=InputData) 
        # ? 2 soup = BeautifulSoup(res.content, 'html.parser')
        # ? 3 self.__LeaksResult = soup.find('div', {'class': 'ResultPanel'})
        # ? 1+2 soup = BeautifulSoup(self.session.post('http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion/LeakedPass', data=InputData) .content, 'html.parser')
        res = self.session.post('http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion/LeakedPass', data=InputData)
        self.AddStatus('[-] Search Result received [-]')
        soup = BeautifulSoup(res.content, 'html.parser')
        self.__LeaksResult = soup.find('div', {'class': 'ResultPanel'})        
        # ? 1+2+3 
        self.__LeaksResult = BeautifulSoup(self.session.post('http://leakfindrg5s2zcwwdmxlvz6oefz6hdwlkckh4eir4huqcpjsefxkead.onion/LeakedPass', data=InputData).content, 'html.parser').find('div', {'class': 'ResultPanel'})
        if self.__LeaksResult:
            self.__HandleLeaks()
            self.AddStatus('[+] Breaches Found in the Dark web [+]')
            
        else:
            self.AddResult('No Leaks Found In the dark web')


    def __HandleLeaks(self):  
        for span in self.__LeaksResult.find_all('span', {'style':'display:inline-block;color:White;background-color:DarkRed;border-width:2px;border-style:Solid;'}):
            self.AddResult(span.contents.pop())
            self.IncreaseRiskLevel()# Omar Khaled 
import sqlite3  
from modules.leaksfinder import LeaksFinder

class Database(LeaksFinder):        
    def __init__(self):
        print('creating an object')
        pass
        
    def __DBConnect(self, DatabaseName):
        self.__conn = sqlite3.connect(f'{DatabaseName}.db')
        self.__cursor = self.__conn.cursor()

    
    def Search(self, DatabaseName):
        self.__DBConnect(DatabaseName) 
        print('connected')
        try:
            table = self.__cursor.execute("SELECT name FROM sqlite_master WHERE type='table'").fetchall()[0][0]
            print('table name ')
        except:
            print('except')
            return False
        query = f"PRAGMA table_info({table})"
        self.__cursor.execute(query)
        column = self.__cursor.fetchall()[0][1]
        print(f'col name {column}')
        query = f"SELECT {column} FROM {table} WHERE {column}='{self.GetSearchKey}'"
        self.__cursor.execute(query)

        try:
            
            result = self.__cursor.fetchall()  # ! TODO search for solution 
            print(f'result -> {result}')
            
            if self.GetSearchKey in str(result):
                LeaksFinder.AddResult('found ksdfjlskjdfkls')
                return True
        except :
            
            LeaksFinder.AddResult('not found')
            return False
        
        finally:
            self.__cursor.close()
        
    
    
    def InsertRecord(self, Values): # ? Values is a list 
        self.__DBConnect('databases/History')
        self.__cursor.execute(f"INSERT INTO History VALUES('{Values[0]}', '{Values[1]}', '{Values[2]}', '{Values[3]}', '{Values[4]}')")
        self.__conn.commit()
        self.__conn.close()


    def HistorySearch(self):
        self.__DBConnect('{}History'.format(LeaksFinder.FileSystemStructure()))
        self.__cursor.execute(f"SELECT * FROM History WHERE SearchKey='{self.GetSearchKey}'")
        try:
            row = self.__cursor.fetchall()[0]
        except:
            return False
        
        if self.GetSearchKey in row[0]:
            self.AddResult(row[1])
            self.AddSource(row[2])
            self.SetLastSearch(row[3])
            self.SetRiskLevel(row[4])
            self.__conn.close()
            return True
        else:
            return False
    





# |SearchKey|Result|Sources|LastSearch|RiskLevel
# 
# ! CREATE TABLE History(SearchKey VARCHAR(50) PRIMARY KEY, Result VARCHAR(10000), Sources VARCHAR(10000), LastSearch date, RiskLevel INT )# Hawash
# class Methods:
# Search
# Connect
# CheckConnection
# DetectDataFormat
# PlainTextSearch
# PdfSearch
# class attributes:
# Result
# Status
from modules.leaksfinder import LeaksFinder
from requests import get

class Internet(LeaksFinder):
    
    @property
    def CheckConnection(self):
        URLs = ['http://google.com',
                'http://innergrandmajesticmorning.neverssl.com/online', 
                ]
        for URL in URLs:
            if get(URL):
                return True
        return False
    
    
    def GetCountry():
        return get('https://am.i.mullvad.net/country').text.replace('\n', '')
        
        
from datetime import date ,timedelta,datetime
from bs4 import BeautifulSoup
from requests import get 
from sys import platform 
from os import getcwd
from datetime import timedelta

RED = '\033[93m'
YELLOW = '\033[33m'
UNDERLINE = '\033[4m'
CYAN = '\033[36m'
GREEN = '\033[32m'
RESET = '\033[0m'
BOLD = '\033[1m'
HEADER = '\033[95m'


class LeaksFinder():
    __SearchKey = ""
    __SearchType = ""
    __Status = ""
    __Result = ""
    __Source = ""
    __RiskLevel = 0
    __LastSearch = date.today()
    __Today = date.today()
    __CWD = getcwd()
    
    
    
    
    @staticmethod
    def SetAtrrs(InputSearchKey, InputSearchType):
        LeaksFinder.__SearchKey = InputSearchKey
        LeaksFinder.__SearchType = InputSearchType
        
        
    @staticmethod
    def IncreaseRiskLevel():
        LeaksFinder.__RiskLevel += 1
        
    
    def GetRiskLevel():
        return LeaksFinder.__RiskLevel
    
    
    def SetLastSearch(self, NewValue):
        self.__LastSearch = NewValue
    
    
    def SetRiskLevel(self, NewValue):
        self.__RiskLevel = NewValue
        
        
    def GetLastSearch():
        return LeaksFinder.__LastSearch
    
    
    @staticmethod
    def AddSource(NewSource):
        LeaksFinder.__Source += NewSource + '\n' 
    
    
    def GetSources():
        return LeaksFinder.__Source
    
    
    @staticmethod
    def AddResult(NewResult):
        if NewResult not in LeaksFinder.__Result:
            LeaksFinder.__Result += NewResult + '\n'
    
    
    def GetResult():
        return LeaksFinder.__Result
        
        
    @staticmethod
    def AddStatus(NewStatus):
        if str(NewStatus).startswith('[*]'):
            print(HEADER + '___________________________________________\n' + BOLD + GREEN + NewStatus + RESET)
        elif str(NewStatus).startswith('[+]'):
            print(YELLOW + UNDERLINE + NewStatus + RESET)
        else:
            print(CYAN + NewStatus  + RESET)
            
        LeaksFinder.__Status += NewStatus + '\n'
        
    
    
    def GetStatus():
        return LeaksFinder.__Status
    
    @property
    def GetSearchKey(self):
        return self.__SearchKey
    
    @property 
    def GetSearchType(self):
        return self.__SearchType

    @property
    def CheckConnection(self):
        URLs = ['http://google.com', ]
        for URL in URLs:
            if get(URL):
                return True
        return False
    
    
    def GetCountry():
        return get('https://am.i.mullvad.net/country').text.replace('\n', '')
    
    
    def TrustHistory():
        d1 = datetime.strptime(str(LeaksFinder.GetLastSearch()), "%Y-%m-%d")
        d2 = datetime.strptime(str(LeaksFinder.__Today), "%Y-%m-%d")
        return abs((d2 - d1).days) < 30
    
    
    def FileSystemStructure():
        if platform == 'Linux' or platform == 'linux' or platform == 'Darwin':
            return f'{LeaksFinder.__CWD}/databases/'
        elif platform == 'win32' or platform == 'windows':
            return f'{LeaksFinder.__CWD}\databases'   
        else:
            # ! show error winow 
            passfrom modules.internet import Internet
from requests import session
from bs4 import BeautifulSoup

#!status
"""
Scatter Attributes: 
    self.
        __ScatterSoup
        __ResponseHeaders 
        __SessionVal
        __ScatterCSRF
        
        
Scatter Method:
    self.
        __GetContent()
        __GetCookie()
        __GetCSRF()
        __CheckResult
        Search()
        
"""  

class ScatterSecrets(Internet):
    
    def __init__(self):
        self.__ResponseHeaders = ""
        self.__ScatterSoup = ""
        self.__CSRFToken = ""
        self.__SessionVal = ""
        

        self.Session = session() 
        self.__GetContent()
        self.__GetCookie()
        self.__GetCSRF()


    def __GetContent(self):
        self.AddStatus("[-] Establishing connection with Scatter Secrets.")
        res = self.Session.get('https://scatteredsecrets.com/')  
        self.__ScatterSoup = BeautifulSoup(res.content, 'html.parser')
        self.__ResponseHeaders = res.headers
        
    def __GetCookie(self):
        self.AddStatus("[-] Create a new ScatterSecrets session. [-]")
        self.__SessionVal = self.__ResponseHeaders['set-cookie'].split(';')[0].split('=')[1]
        self.Session.cookies.set('session', self.__SessionVal)
        
    def __GetCSRF(self):
        # tag = self.__ScatterSoup.find('input', {'type': 'hidden', 'name': 'csrf_token'})
        # self.__ScatterCSRF = tag.attrs['value']
        self.__CSRFToken = self.__ScatterSoup.find('input', {'type': 'hidden', 'name': 'csrf_token'}).attrs['value']

        
    def Search(self):
        self.AddStatus('[*] Start searching in ScaterSecrets. [*]')
        InputHeaders = {
            "Host": "scatteredsecrets.com",
            "User-Agent": "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:98.0) Gecko/20100101 Firefox/98.0",
            # "Cookie": f"session={self.__SessionVal}",
            "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Referer": "https://scatteredsecrets.com/",
            "Content-Type": "application/x-www-form-urlencoded",
            "Origin": "https://scatteredsecrets.com",
            "Upgrade-Insecure-Requests": "1",
            "Sec-Fetch-Dest": "document",
            "Sec-Fetch-Mode": "navigate",
            "Sec-Fetch-Site": "same-origin",
            "Sec-Fetch-User": "?1",
            "Te": "trailers"
        }

        Parameters = {"identifier" : self.GetSearchKey,
                    "csrf_token" : self.__CSRFToken,
                    "action" : "search"
                    }
        content = self.Session.post('https://scatteredsecrets.com/', headers=InputHeaders, data=Parameters, allow_redirects=True).content
        self.AddStatus('[-] Search Result received [-]')
        soup = BeautifulSoup(content, 'html.parser')
        self.AddStatus('[-] ScatterSecrets reponded [-]')
        self.__Result = soup.find('small', {'class': 'alerter'}).contents
        self.__Result = self.__Result.pop()
        if self.__CheckResult():
            self.AddStatus('[+] BREACHES Found in ScatterSecrets [+]')
            self.AddResult(self.__Result)
        else:
            self.AddStatus("[+] You're SAFE :) [+]")
            self.AddResult('No Breaches found in ScatterSecrets')
            
        

    def __CheckResult(self):
        if f"Bad news. Leaked passwords found for {self.GetSearchKey}." == self.__Result:
            return True 
        else:
            return Falsefrom modules.leaksfinder import LeaksFinder
from modules.internet import Internet 
from modules.darknet import DarkNet
from modules.scatter import ScatterSecrets
from modules.database import Database
from modules.breachdir import BreachDir
from modules.validateinput import CheckinputType
from threading import Thread
from datetime import date 
import time


class Search():

            
            
    def __EmailSearch(self):
        self.BreachDirFinder = BreachDir()
        self.ScatterFinder = ScatterSecrets()
        self.DarkFinder = DarkNet()
    
        start = time.time()



        t1 = Thread(target=self.ScatterFinder.Search)
        t2 = Thread(target=self.BreachDirFinder.Search)
        t3 = Thread(target=self.DarkFinder.Search)
        threads = [t1, t2, t3]
        
        for thread in threads:
            start = time.time()
            thread.start()
            thread.join()
            print(f'Time: {time.time() - start}')
            
        # for thread in threads:
        #     
            
           
            
            
    
    def __UsernameSearch(self):
        t1 = Thread(target=self.BreachDirFinder.Search)
        t2 = Thread(target=self.DarkFinder.Search)
        t2.start()
        t1.start()
        for i in [t1, t2]:
            i.join()
            
            
    def Search(self, SearchKey):
        if type(SearchKey) == str:
            self.__SingleSearch(SearchKey)
            
        elif type(SearchKey) == list:
            for key in SearchKey:
                self.__SingleSearch(key)


    def __SingleSearch(self, SearchKey):
        start = time.time()
        
        SearchType = CheckinputType(SearchKey)

        if LeaksFinder.GetCountry != 'Israel':
            
            LeaksFinder.SetAtrrs(SearchKey, SearchType)
            start = time.time()

            self.DatabaseFinder = Database()
            print('create db object -> Time: {} - {}'.format(time.time(), start))
            start = time.time()
            
            if self.DatabaseFinder.HistorySearch():
                print(f'history db object -> Time: {time.time() - start}')
                
                if not LeaksFinder.TrustHistory():
                    start = time.time()
                    print('before external search')
                    self.__ExternalSearch(SearchType)
                    print(f'external object -> Time: {time.time() - start}')
                    
            else:
                print('here')
                self.__ExternalSearch(SearchType)
        else:
            #ISRAEL
            pass
        print(f'search -> Time: {time.time() - start}')
        
            
            
    def __ExternalSearch(self, SearchType):
        print(f'Search type -> {SearchType}')
        if SearchType == 'Email':
            self.__EmailSearch()
        elif SearchType == 'Username':
            self.__UsernameSearch()
            
        elif SearchType == 'PhoneNumber':
            self.DatabaseFinder.Search('{}{}'.format(LeaksFinder.FileSystemStructure(), Internet.GetCountry()))
            
        elif SearchType == 'Visa':
            print(LeaksFinder.FileSystemStructure())
            self.DatabaseFinder.Search('{}Visa'.format(LeaksFinder.FileSystemStructure()))
        else:
            #! show error window 
            pass
        self.DatabaseFinder.InsertRecord([
                                self.DatabaseFinder.GetSearchKey,
                                LeaksFinder.GetResult(),
                                LeaksFinder.GetSources(),
                                date.today(), 
                                LeaksFinder.GetRiskLevel()])
        self.DatabaseFinder.HistorySearch()
        
from modules.internet import Internet

country = Internet.GetCountry()
def CheckinputType(data):
    if IsEmail(data) :
        return "Email"
    elif IsVisa(data):
        return "Visa"
    elif  IsPhoneNumber(data):
        return "PhoneNumber"

    elif data.isalpha():
        return "Username"

def IsEmail(email_address):
    return True if '@' in email_address and '.com' in email_address else False

def IsVisa(Visa):
    if len(Visa) == 11 and Visa[5] == '-':
        return True
    
countries = {
    "Egypt": [2, 11, 13],
    "Cameroon":[237 ,9, 12],
    "Austria":[43,9,15],
    "Canada":[ 1, 9, 12],
    "Bahrain":[973,3,8],
    "Belgium":[ 32, 12,15 ],
    "China":[ 86, 10, 13],
    "Isreal" : [972 ,9 , 12]
}



def IsPhoneNumber(Number):
    
    if Number[0] == '+' :
        l = list(Number)
        l.remove('+')
        Number = ''.join(l)
    return HandilingPhoneformat(str(countries[country][0]), countries[country][1], countries[country][2],Number)

    
def HandilingPhoneformat(code , StartRange, EndRange,Number):

    if Number[:len((code))] != code:
        l = list(Number)
        l.insert(0,code)
        Number = ''.join(l)

    return (len(Number) >= StartRange and len(Number)<=EndRange ) and Number.isnumeric() and Number[:len(code)] == code


